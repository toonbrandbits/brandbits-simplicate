
from typing import List, Optional
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import asyncpg
import databutton as db
from app.auth import AuthorizedUser
from datetime import date

router = APIRouter(prefix="/time-entries")

# Pydantic Models
class TimeEntryCreateRequest(BaseModel):
    company_id: int
    project_id: int
    date: date
    hours_worked: float

class TimeEntryUpdateRequest(BaseModel):
    hours_worked: float

class TimeEntryResponse(BaseModel):
    id: int
    employee_id: int
    company_id: int
    company_name: str
    project_id: int
    project_name: str
    date: str
    hours_worked: float
    created_at: str

class TimeEntriesListResponse(BaseModel):
    time_entries: List[TimeEntryResponse]
    total: int

class ProjectCompanyAvailableHours(BaseModel):
    company_id: int
    company_name: str
    project_id: int
    project_name: str
    available_hours: float
    used_hours: float
    remaining_hours: float

class AvailableHoursResponse(BaseModel):
    project_companies: List[ProjectCompanyAvailableHours]

# Database connection helper
async def get_db_connection():
    database_url = db.secrets.get("DATABASE_URL_DEV")
    return await asyncpg.connect(database_url)

# Helper functions
async def get_or_create_employee(conn: asyncpg.Connection, user: AuthorizedUser) -> int:
    # Use user.sub as the unique identifier and email if available
    user_id = user.sub
    user_email = getattr(user, 'email', None) or getattr(user, 'primary_email', None) or f"{user_id}@timeflow.local"
    user_name = getattr(user, 'display_name', None) or user_email
    
    # Try to find employee by auth user ID first, then by email
    employee_query = "SELECT id FROM employees WHERE email = $1 OR email = $2"
    employee_row = await conn.fetchrow(employee_query, user_email, user_id)
    
    if employee_row:
        return employee_row['id']
    
    create_query = """
        INSERT INTO employees (name, email)
        VALUES ($1, $2)
        RETURNING id
    """
    
    new_employee = await conn.fetchrow(create_query, user_name, user_email)
    return new_employee['id']

# API Endpoints
@router.post("/", response_model=TimeEntryResponse)
async def create_time_entry(entry: TimeEntryCreateRequest, user: AuthorizedUser):
    if entry.hours_worked < 0 or entry.hours_worked > 24:
        raise HTTPException(status_code=400, detail="Hours worked must be between 0 and 24")
    
    conn = await get_db_connection()
    try:
        async with conn.transaction():
            employee_id = await get_or_create_employee(conn, user)
            
            # Validate project-company combination exists
            pc_query = "SELECT available_hours FROM project_companies WHERE project_id = $1 AND company_id = $2"
            pc_row = await conn.fetchrow(pc_query, entry.project_id, entry.company_id)
            
            if not pc_row:
                raise HTTPException(
                    status_code=400, 
                    detail=f"Project {entry.project_id} is not linked to company {entry.company_id}"
                )
            
            available_hours = float(pc_row['available_hours'])
            
            # Check current usage
            used_query = """
                SELECT COALESCE(SUM(hours_worked), 0) as total_used 
                FROM time_entries 
                WHERE project_id = $1 AND company_id = $2
            """
            used_row = await conn.fetchrow(used_query, entry.project_id, entry.company_id)
            current_used = float(used_row['total_used'])
            
            if current_used + entry.hours_worked > available_hours:
                remaining = available_hours - current_used
                raise HTTPException(
                    status_code=400,
                    detail=f"Cannot log {entry.hours_worked} hours. Only {remaining} hours remaining."
                )
            
            # Check for duplicate entry
            duplicate_query = """
                SELECT id FROM time_entries 
                WHERE employee_id = $1 AND company_id = $2 AND project_id = $3 AND date = $4
            """
            if await conn.fetchrow(duplicate_query, employee_id, entry.company_id, entry.project_id, entry.date):
                raise HTTPException(
                    status_code=400,
                    detail="A time entry already exists for this date, company, and project."
                )
            
            # Insert time entry
            insert_query = """
                INSERT INTO time_entries (employee_id, company_id, project_id, date, hours_worked)
                VALUES ($1, $2, $3, $4, $5)
                RETURNING id, employee_id, company_id, project_id, date, hours_worked, created_at
            """
            
            entry_row = await conn.fetchrow(
                insert_query, employee_id, entry.company_id, entry.project_id, entry.date, entry.hours_worked
            )
            
            # Get company and project names
            names_query = """
                SELECT c.company_name, p.project_name
                FROM companies c, projects p
                WHERE c.id = $1 AND p.id = $2
            """
            names_row = await conn.fetchrow(names_query, entry.company_id, entry.project_id)
            
            return TimeEntryResponse(
                id=entry_row['id'],
                employee_id=entry_row['employee_id'],
                company_id=entry_row['company_id'],
                company_name=names_row['company_name'],
                project_id=entry_row['project_id'],
                project_name=names_row['project_name'],
                date=entry_row['date'].isoformat(),
                hours_worked=float(entry_row['hours_worked']),
                created_at=entry_row['created_at'].isoformat()
            )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        await conn.close()

@router.get("/", response_model=TimeEntriesListResponse)
async def list_time_entries(
    user: AuthorizedUser,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None
):
    conn = await get_db_connection()
    try:
        employee_id = await get_or_create_employee(conn, user)
        
        where_conditions = ["te.employee_id = $1"]
        params = [employee_id]
        param_count = 1
        
        if start_date:
            param_count += 1
            where_conditions.append(f"te.date >= ${param_count}")
            params.append(start_date)
            
        if end_date:
            param_count += 1
            where_conditions.append(f"te.date <= ${param_count}")
            params.append(end_date)
        
        query = f"""
            SELECT te.id, te.employee_id, te.company_id, c.company_name,
                   te.project_id, p.project_name, te.date, te.hours_worked, te.created_at
            FROM time_entries te
            JOIN companies c ON te.company_id = c.id
            JOIN projects p ON te.project_id = p.id
            WHERE {' AND '.join(where_conditions)}
            ORDER BY te.date DESC, te.created_at DESC
        """
        
        entries_rows = await conn.fetch(query, *params)
        
        time_entries = [
            TimeEntryResponse(
                id=row['id'],
                employee_id=row['employee_id'],
                company_id=row['company_id'],
                company_name=row['company_name'],
                project_id=row['project_id'],
                project_name=row['project_name'],
                date=row['date'].isoformat(),
                hours_worked=float(row['hours_worked']),
                created_at=row['created_at'].isoformat()
            )
            for row in entries_rows
        ]
        
        return TimeEntriesListResponse(
            time_entries=time_entries,
            total=len(time_entries)
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        await conn.close()

@router.get("/available-hours", response_model=AvailableHoursResponse)
async def get_available_hours(user: AuthorizedUser):
    conn = await get_db_connection()
    try:
        query = """
            SELECT 
                pc.company_id, c.company_name,
                pc.project_id, p.project_name,
                pc.available_hours,
                COALESCE(SUM(te.hours_worked), 0) as used_hours
            FROM project_companies pc
            JOIN companies c ON pc.company_id = c.id
            JOIN projects p ON pc.project_id = p.id
            LEFT JOIN time_entries te ON pc.project_id = te.project_id AND pc.company_id = te.company_id
            GROUP BY pc.company_id, c.company_name, pc.project_id, p.project_name, pc.available_hours
            ORDER BY c.company_name, p.project_name
        """
        
        rows = await conn.fetch(query)
        
        project_companies = [
            ProjectCompanyAvailableHours(
                company_id=row['company_id'],
                company_name=row['company_name'],
                project_id=row['project_id'],
                project_name=row['project_name'],
                available_hours=float(row['available_hours']),
                used_hours=float(row['used_hours']),
                remaining_hours=float(row['available_hours']) - float(row['used_hours'])
            )
            for row in rows
        ]
        
        return AvailableHoursResponse(
            project_companies=project_companies
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        await conn.close()

@router.delete("/{entry_id}")
async def delete_time_entry(entry_id: int, user: AuthorizedUser):
    conn = await get_db_connection()
    try:
        employee_id = await get_or_create_employee(conn, user)
        
        delete_query = "DELETE FROM time_entries WHERE id = $1 AND employee_id = $2"
        result = await conn.execute(delete_query, entry_id, employee_id)
        
        if result == "DELETE 0":
            raise HTTPException(status_code=404, detail="Time entry not found")
        
        return {"message": "Time entry deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        await conn.close()
