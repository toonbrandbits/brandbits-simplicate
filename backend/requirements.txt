from typing import List, Optional
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, field_validator
import asyncpg
import databutton as db
from app.auth import AuthorizedUser
from datetime import date, time, datetime, timedelta

router = APIRouter(prefix="/time-entries")

# ---------------- Pydantic Models ----------------

class TimeEntryCreateRequest(BaseModel):
    company_id: int
    project_id: int
    date: date
    # je mag óf hours_worked meesturen, óf start/end time (of allebei; dan valideren we)
    hours_worked: Optional[float] = None
    start_time: Optional[time] = None
    end_time: Optional[time] = None

    @field_validator("hours_worked")
    @classmethod
    def _validate_hours_range(cls, v):
        if v is None:
            return v
        if v < 0 or v > 24:
            raise ValueError("Hours worked must be between 0 and 24")
        return v


class TimeEntryUpdateRequest(BaseModel):
    hours_worked: Optional[float] = None
    start_time: Optional[time] = None
    end_time: Optional[time] = None

    @field_validator("hours_worked")
    @classmethod
    def _validate_hours_range(cls, v):
        if v is None:
            return v
        if v < 0 or v > 24:
            raise ValueError("Hours worked must be between 0 and 24")
        return v


class TimeEntryResponse(BaseModel):
    id: int
    employee_id: int
    company_id: int
    company_name: str
    project_id: int
    project_name: str
    date: str
    hours_worked: float
    start_time: Optional[str] = None
    end_time: Optional[str] = None
    created_at: str


class TimeEntriesListResponse(BaseModel):
    time_entries: List[TimeEntryResponse]
    total: int


class ProjectCompanyAvailableHours(BaseModel):
    company_id: int
    company_name: str
    project_id: int
    project_name: str
    available_hours: float
    used_hours: float
    remaining_hours: float


class AvailableHoursResponse(BaseModel):
    project_companies: List[ProjectCompanyAvailableHours]

# ---------------- DB helper ----------------

async def get_db_connection():
    database_url = db.secrets.get("DATABASE_URL_DEV")
    return await asyncpg.connect(database_url)

# ---------------- Helpers ----------------

async def get_or_create_employee(conn: asyncpg.Connection, user: AuthorizedUser) -> int:
    user_id = user.sub
    user_email = getattr(user, 'email', None) or getattr(user, 'primary_email', None) or f"{user_id}@timeflow.local"
    user_name = getattr(user, 'display_name', None) or user_email

    employee_query = "SELECT id FROM employees WHERE email = $1 OR email = $2"
    employee_row = await conn.fetchrow(employee_query, user_email, user_id)
    if employee_row:
        return employee_row['id']

    create_query = """
        INSERT INTO employees (name, email)
        VALUES ($1, $2)
        RETURNING id
    """
    new_employee = await conn.fetchrow(create_query, user_name, user_email)
    return new_employee['id']


def _duration_hours_from_times(d: date, start_t: time, end_t: time) -> float:
    # aannames: dezelfde dag (geen overnight logging)
    start_dt = datetime.combine(d, start_t)
    end_dt = datetime.combine(d, end_t)
    if end_dt <= start_dt:
        raise HTTPException(status_code=400, detail="end_time must be after start_time")
    duration = end_dt - start_dt
    return duration.total_seconds() / 3600.0


async def _has_overlap(conn: asyncpg.Connection, employee_id: int, d: date, start_t: time, end_t: time, exclude_id: Optional[int] = None) -> bool:
    """
    Check overlapping entries for the same employee & date.
    We consider overlap when NOT (existing_end <= new_start OR existing_start >= new_end).
    Null start/end in DB are ignored for overlap logic.
    """
    where = "employee_id = $1 AND date = $2 AND start_time IS NOT NULL AND end_time IS NOT NULL"
    params = [employee_id, d]

    if exclude_id is not None:
        where += " AND id <> $3"
        params.append(exclude_id)

    query = f"""
        SELECT 1
        FROM time_entries
        WHERE {where}
          AND NOT (end_time <= $4 OR start_time >= $5)
        LIMIT 1
    """
    params.extend([start_t, end_t])
    row = await conn.fetchrow(query, *params)
    return row is not None

# ---------------- API ----------------

@router.post("/", response_model=TimeEntryResponse)
async def create_time_entry(entry: TimeEntryCreateRequest, user: AuthorizedUser):
    # Basisvalidering van invoercombinaties
    if entry.start_time and entry.end_time:
        # bereken uren op basis van tijden
        computed = _duration_hours_from_times(entry.date, entry.start_time, entry.end_time)
        if entry.hours_worked is not None:
            # als beide zijn meegegeven moeten ze (ongeveer) overeenkomen
            if abs(entry.hours_worked - computed) > 1e-6:
                raise HTTPException(status_code=400, detail="hours_worked must match the duration between start_time and end_time")
        entry.hours_worked = computed
    elif entry.hours_worked is None:
        # geen tijden en geen uren -> invalid
        raise HTTPException(status_code=400, detail="Provide either hours_worked, or start_time and end_time")

    if entry.hours_worked < 0 or entry.hours_worked > 24:
        raise HTTPException(status_code=400, detail="Hours worked must be between 0 and 24")

    conn = await get_db_connection()
    try:
        async with conn.transaction():
            employee_id = await get_or_create_employee(conn, user)

            # Valideer project-company combinatie
            pc_query = "SELECT available_hours FROM project_companies WHERE project_id = $1 AND company_id = $2"
            pc_row = await conn.fetchrow(pc_query, entry.project_id, entry.company_id)
            if not pc_row:
                raise HTTPException(
                    status_code=400,
                    detail=f"Project {entry.project_id} is not linked to company {entry.company_id}",
                )

            available_hours = float(pc_row["available_hours"])

            # Check huidige verbruik
            used_query = """
                SELECT COALESCE(SUM(hours_worked), 0) as total_used
                FROM time_entries
                WHERE project_id = $1 AND company_id = $2
            """
            used_row = await conn.fetchrow(used_query, entry.project_id, entry.company_id)
            current_used = float(used_row["total_used"])

            if current_used + float(entry.hours_worked) > available_hours:
                remaining = available_hours - current_used
                raise HTTPException(
                    status_code=400,
                    detail=f"Cannot log {entry.hours_worked} hours. Only {remaining} hours remaining.",
                )

            # Overlapcontrole (alleen als tijden zijn opgegeven)
            if entry.start_time and entry.end_time:
                if await _has_overlap(conn, employee_id, entry.date, entry.start_time, entry.end_time):
                    raise HTTPException(
                        status_code=400,
                        detail="This time range overlaps with an existing entry for this day.",
                    )

            # Invoegen
            insert_query = """
                INSERT INTO time_entries (employee_id, company_id, project_id, date, hours_worked, start_time, end_time)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
                RETURNING id, employee_id, company_id, project_id, date, hours_worked, start_time, end_time, created_at
            """
            row = await conn.fetchrow(
                insert_query,
                employee_id,
                entry.company_id,
                entry.project_id,
                entry.date,
                float(entry.hours_worked),
                entry.start_time,
                entry.end_time,
            )

            # Namen ophalen
            names_query = """
                SELECT c.company_name, p.project_name
                FROM companies c, projects p
                WHERE c.id = $1 AND p.id = $2
            """
            names_row = await conn.fetchrow(names_query, entry.company_id, entry.project_id)

            return TimeEntryResponse(
                id=row["id"],
                employee_id=row["employee_id"],
                company_id=row["company_id"],
                company_name=names_row["company_name"],
                project_id=row["project_id"],
                project_name=names_row["project_name"],
                date=row["date"].isoformat(),
                hours_worked=float(row["hours_worked"]),
                start_time=row["start_time"].isoformat() if row["start_time"] else None,
                end_time=row["end_time"].isoformat() if row["end_time"] else None,
                created_at=row["created_at"].isoformat(),
            )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        await conn.close()


@router.get("/", response_model=TimeEntriesListResponse)
async def list_time_entries(
    user: AuthorizedUser,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
):
    conn = await get_db_connection()
    try:
        employee_id = await get_or_create_employee(conn, user)

        where_conditions = ["te.employee_id = $1"]
        params = [employee_id]
        param_count = 1

        if start_date:
            param_count += 1
            where_conditions.append(f"te.date >= ${param_count}")
            params.append(start_date)

        if end_date:
            param_count += 1
            where_conditions.append(f"te.date <= ${param_count}")
            params.append(end_date)

        query = f"""
            SELECT te.id, te.employee_id, te.company_id, c.company_name,
                   te.project_id, p.project_name, te.date, te.hours_worked,
                   te.start_time, te.end_time, te.created_at
            FROM time_entries te
            JOIN companies c ON te.company_id = c.id
            JOIN projects p ON te.project_id = p.id
            WHERE {' AND '.join(where_conditions)}
            ORDER BY te.date DESC, te.start_time NULLS LAST, te.created_at DESC
        """

        rows = await conn.fetch(query, *params)

        time_entries = [
            TimeEntryResponse(
                id=r["id"],
                employee_id=r["employee_id"],
                company_id=r["company_id"],
                company_name=r["company_name"],
                project_id=r["project_id"],
                project_name=r["project_name"],
                date=r["date"].isoformat(),
                hours_worked=float(r["hours_worked"]),
                start_time=r["start_time"].isoformat() if r["start_time"] else None,
                end_time=r["end_time"].isoformat() if r["end_time"] else None,
                created_at=r["created_at"].isoformat(),
            )
            for r in rows
        ]

        return TimeEntriesListResponse(time_entries=time_entries, total=len(time_entries))

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        await conn.close()


@router.get("/available-hours", response_model=AvailableHoursResponse)
async def get_available_hours(user: AuthorizedUser):
    conn = await get_db_connection()
    try:
        query = """
            SELECT 
                pc.company_id, c.company_name,
                pc.project_id, p.project_name,
                pc.available_hours,
                COALESCE(SUM(te.hours_worked), 0) as used_hours
            FROM project_companies pc
            JOIN companies c ON pc.company_id = c.id
            JOIN projects p ON pc.project_id = p.id
            LEFT JOIN time_entries te ON pc.project_id = te.project_id AND pc.company_id = te.company_id
            GROUP BY pc.company_id, c.company_name, pc.project_id, p.project_name, pc.available_hours
            ORDER BY c.company_name, p.project_name
        """
        rows = await conn.fetch(query)
        project_companies = [
            ProjectCompanyAvailableHours(
                company_id=row["company_id"],
                company_name=row["company_name"],
                project_id=row["project_id"],
                project_name=row["project_name"],
                available_hours=float(row["available_hours"]),
                used_hours=float(row["used_hours"]),
                remaining_hours=float(row["available_hours"]) - float(row["used_hours"]),
            )
            for row in rows
        ]
        return AvailableHoursResponse(project_companies=project_companies)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        await conn.close()


@router.delete("/{entry_id}")
async def delete_time_entry(entry_id: int, user: AuthorizedUser):
    conn = await get_db_connection()
    try:
        employee_id = await get_or_create_employee(conn, user)
        result = await conn.execute("DELETE FROM time_entries WHERE id = $1 AND employee_id = $2", entry_id, employee_id)
        if result == "DELETE 0":
            raise HTTPException(status_code=404, detail="Time entry not found")
        return {"message": "Time entry deleted successfully"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    finally:
        await conn.close()
